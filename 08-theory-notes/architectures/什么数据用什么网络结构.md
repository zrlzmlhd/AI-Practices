# 数据类型与神经网络架构选择指南

## 核心原则

选择合适的网络架构是深度学习项目成功的关键。不同类型的数据具有不同的结构特性，需要匹配相应的网络架构来有效提取特征。

---

## 数据类型与推荐架构

### 1. 向量数据（表格数据）
**推荐架构**: Dense层（全连接层）

**数据特征**:
- 结构化数据（CSV、数据库表）
- 特征之间无明显空间关系
- 每个样本是固定长度的特征向量

**典型应用**:
- 房价预测
- 信用评分
- 疾病诊断
- 客户流失预测

**示例**:
```python
model = models.Sequential([
    layers.Dense(128, activation='relu', input_shape=(n_features,)),
    layers.Dropout(0.3),
    layers.Dense(64, activation='relu'),
    layers.Dense(num_classes, activation='softmax')
])
```

---

### 2. 图像数据
**推荐架构**: Conv2D（二维卷积层）

**数据特征**:
- 2D空间结构（高度×宽度×通道）
- 局部特征（边缘、纹理、形状）
- 平移不变性

**典型应用**:
- 图像分类
- 目标检测
- 图像分割
- 人脸识别

**关键技术**:
- 多层卷积 + 池化
- 残差连接（ResNet）
- 批归一化
- 数据增强

**示例**:
```python
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(height, width, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(num_classes, activation='softmax')
])
```

---

### 3. 声音数据
**推荐架构**: Conv1D（一维卷积） > RNN

**数据特征**:
- 一维时间序列
- 频谱特征（Mel频谱、MFCC）
- 时序模式

**典型应用**:
- 语音识别
- 说话人识别
- 音乐分类
- 环境声音检测

**推荐方案**:
1. **首选**: 将音频转为频谱图，使用Conv2D
2. **次选**: 使用Conv1D处理原始波形或特征序列
3. **可选**: LSTM/GRU用于序列建模

**示例**:
```python
# 方案1: 频谱图 + Conv2D
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(128, time_steps, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.GlobalAveragePooling2D(),
    layers.Dense(num_classes, activation='softmax')
])

# 方案2: Conv1D
model = models.Sequential([
    layers.Conv1D(64, 3, activation='relu', input_shape=(time_steps, n_features)),
    layers.MaxPooling1D(2),
    layers.Conv1D(128, 3, activation='relu'),
    layers.GlobalAveragePooling1D(),
    layers.Dense(num_classes, activation='softmax')
])
```

---

### 4. 文本数据
**推荐架构**: Conv1D（短文本） / RNN（长文本）/ Transformer（SOTA）

**数据特征**:
- 序列数据（词序列）
- 长距离依赖
- 语义信息

**典型应用**:
- 情感分析
- 文本分类
- 命名实体识别
- 机器翻译

**架构选择**:
| 架构 | 适用场景 | 优势 | 劣势 |
|------|---------|------|------|
| **Conv1D** | 短文本分类 | 快速、并行 | 难以捕捉长距离依赖 |
| **LSTM/GRU** | 中等长度文本 | 捕捉时序依赖 | 训练慢、串行处理 |
| **Transformer** | 长文本、复杂任务 | SOTA性能 | 计算量大、需要大量数据 |

**示例**:
```python
# Conv1D方案
model = models.Sequential([
    layers.Embedding(vocab_size, embedding_dim, input_length=maxlen),
    layers.Conv1D(128, 5, activation='relu'),
    layers.GlobalMaxPooling1D(),
    layers.Dense(64, activation='relu'),
    layers.Dense(num_classes, activation='softmax')
])

# LSTM方案
model = models.Sequential([
    layers.Embedding(vocab_size, embedding_dim, input_length=maxlen),
    layers.LSTM(64),
    layers.Dense(num_classes, activation='softmax')
])
```

---

### 5. 时间序列数据
**推荐架构**: RNN（时序重要） > Conv1D（时序不重要）

**数据特征**:
- 强时间依赖
- 趋势、周期、季节性
- 自相关性

**典型应用**:
- 股票预测
- 天气预报
- 负载预测
- 异常检测

**架构选择依据**:
- **时序顺序很重要**（如温度预测）→ LSTM/GRU
- **时序顺序不重要**（如频谱特征）→ Conv1D
- **多变量时序**（如多传感器数据）→ Conv1D + LSTM

**示例**:
```python
# LSTM方案（单步预测）
model = models.Sequential([
    layers.LSTM(50, return_sequences=True, input_shape=(seq_length, n_features)),
    layers.LSTM(50, return_sequences=False),
    layers.Dense(25, activation='relu'),
    layers.Dense(1)  # 回归任务
])

# Conv1D + LSTM方案
model = models.Sequential([
    layers.Conv1D(64, 3, activation='relu', input_shape=(seq_length, n_features)),
    layers.MaxPooling1D(2),
    layers.LSTM(50, return_sequences=False),
    layers.Dense(1)
])
```

---

### 6. 视频数据
**推荐架构**: Conv3D / Conv2D+RNN

**数据特征**:
- 时空数据（时间+空间）
- 运动模式
- 帧间关系

**典型应用**:
- 动作识别
- 视频分类
- 异常行为检测
- 视频描述生成

**两种主流方案**:

**方案A**: Conv3D（直接处理3D体积）
- 优势：直接学习时空特征
- 劣势：计算量大，需要大量数据

**方案B**: Conv2D + RNN（先提取空间特征，再建模时序）
- 优势：利用预训练模型，训练更稳定
- 劣势：两阶段处理，可能丢失时空联合信息

**示例**:
```python
# 方案A: Conv3D
model = models.Sequential([
    layers.Conv3D(32, (3, 3, 3), activation='relu',
                  input_shape=(frames, height, width, 3)),
    layers.MaxPooling3D((2, 2, 2)),
    layers.Conv3D(64, (3, 3, 3), activation='relu'),
    layers.GlobalAveragePooling3D(),
    layers.Dense(num_classes, activation='softmax')
])

# 方案B: Conv2D + LSTM（更常用）
# 步骤1: 对每帧提取特征
base_model = VGG16(include_top=False, input_shape=(height, width, 3))
# 步骤2: 使用TimeDistributed包装
model = models.Sequential([
    layers.TimeDistributed(base_model, input_shape=(frames, height, width, 3)),
    layers.TimeDistributed(layers.Flatten()),
    layers.LSTM(256),
    layers.Dense(num_classes, activation='softmax')
])
```

---

### 7. 3D体积数据
**推荐架构**: Conv3D

**数据特征**:
- 三维空间结构
- 体积特征

**典型应用**:
- 医学影像分析（CT、MRI）
- 3D物体识别
- 分子结构分析

**示例**:
```python
model = models.Sequential([
    layers.Conv3D(32, (3, 3, 3), activation='relu',
                  input_shape=(depth, height, width, 1)),
    layers.MaxPooling3D((2, 2, 2)),
    layers.Conv3D(64, (3, 3, 3), activation='relu'),
    layers.MaxPooling3D((2, 2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(num_classes, activation='softmax')
])
```

---

## 决策树：如何选择架构

```
1. 数据是什么类型？
   ├─ 表格/向量 → Dense
   ├─ 图像 → Conv2D
   ├─ 文本 → Conv1D（短文本）/ LSTM（长文本）
   ├─ 音频 → Conv1D / Conv2D（频谱图）
   ├─ 时间序列 → LSTM（时序重要）/ Conv1D（时序不重要）
   ├─ 视频 → Conv3D / Conv2D+LSTM
   └─ 3D数据 → Conv3D

2. 时间顺序重要吗？
   ├─ 是 → RNN/LSTM/GRU
   └─ 否 → Conv1D/Dense

3. 数据有空间结构吗？
   ├─ 1D → Conv1D
   ├─ 2D → Conv2D
   └─ 3D → Conv3D

4. 序列很长吗（>100步）？
   ├─ 是 → LSTM/GRU（或Transformer）
   └─ 否 → SimpleRNN/Conv1D

5. 计算资源受限吗？
   ├─ 是 → 简单架构（Conv1D/GRU）
   └─ 否 → 复杂架构（LSTM/Transformer/Conv3D）
```

---

## 混合架构建议

现实任务往往需要组合多种架构：

| 任务 | 推荐架构 | 原因 |
|------|---------|------|
| **视频描述生成** | Conv2D + LSTM + Attention | 空间特征 + 时序建模 + 关注机制 |
| **语音识别** | Conv1D + LSTM + CTC | 频谱特征 + 序列建模 + 对齐 |
| **时序图像分类** | Conv2D + LSTM | 帧级特征 + 时序关系 |
| **多模态学习** | Conv2D + LSTM + Dense | 图像 + 文本 + 元数据 |

---

## 实战经验总结

### 1. 优先级原则
1. **首选简单架构**: 先尝试最简单的方案
2. **逐步复杂化**: 性能不够再增加复杂度
3. **数据优先**: 数据质量 > 模型复杂度

### 2. 常见错误
❌ 用Dense处理图像（丢失空间信息）
❌ 用RNN处理无时序关系的数据（过度复杂）
❌ 用Conv3D处理小数据集（过拟合）
❌ 忽略数据预处理（垃圾进垃圾出）

### 3. 性能优化
- **数据增强**: 图像/音频数据
- **迁移学习**: 利用预训练模型
- **集成学习**: 组合多个模型
- **超参数调优**: 系统性搜索

### 4. 架构选择检查清单
- [ ] 分析数据的维度和结构
- [ ] 确定是否有时序依赖
- [ ] 评估计算资源限制
- [ ] 查阅同类任务的SOTA方案
- [ ] 从简单基线开始
- [ ] 逐步优化和调整

---

## 参考资源

- **论文**: 查阅Papers with Code了解SOTA方法
- **预训练模型**: TensorFlow Hub, PyTorch Hub
- **数据集**: Kaggle, UCI ML Repository
- **社区**: GitHub, Stack Overflow
